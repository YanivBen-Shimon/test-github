# Clustering - K-Means | פילוח לקוחות כרטיסי אשראי

## רקע עסקי

חברת **"CardWise"** - חברת כרטיסי אשראי מובילה בישראל. עם הגדילה בבסיס הלקוחות, החברה צריכה להבין טוב יותר את ההתנהגויות השונות של הלקוחות כדי:

- לייעל שיווק ממוקד
- למזער סיכוני אשראי
- להציע מבצעים מותאמים אישית

**המטרה:** לזהות קבוצות לקוחות דומות (segments) באמצעות K-Means Clustering.

---

## מה זה K-Means? (הסבר תיאורטי)

K-Means הוא אלגוריתם **Unsupervised Learning** (למידה לא מפוקחת) - כלומר אין לנו "תשובה נכונה" (label) לכל דוגמה. האלגוריתם מנסה **לגלות מבנה** בנתונים בעצמו.

### שלבי האלגוריתם:

```
1. בחר k נקודות מרכז (centroids) אקראיות
2. שייך כל נקודת נתונים למרכז הקרוב אליה (לפי מרחק אוקלידי)
3. חשב מחדש את המרכזים (ממוצע כל הנקודות בקלאסטר)
4. חזור על שלבים 2-3 עד שהמרכזים לא משתנים (התכנסות)
```

**מרחק אוקלידי** = שורש של סכום ריבועי ההפרשים בין כל התכונות:

```
d(A, B) = sqrt( (x1-x2)^2 + (y1-y2)^2 + ... )
```

---

## תוכן הפתרון

| חלק | נושא | מה עושים |
|-----|-------|----------|
| א' | טעינה ובדיקה | `head()`, `info()`, `describe()`, ערכים חסרים |
| ב' | EDA | קורלציה, היסטוגרמות, scatter, boxplots |
| ג' | קדם-עיבוד | בחירת features, StandardScaler |
| ד' | Elbow | מציאת k אופטימלי |
| ה' | KMeans | אימון, תוויות, פרופילינג |
| ו' | סיכום | תובנות עסקיות והמלצות |

---

## חלק א' - טעינת הנתונים ובדיקה ראשונית

### למה השלב הזה חשוב?

לפני כל מודל, **חייבים** להכיר את הנתונים. טעויות בשלב הזה (למשל, התעלמות מערכים חסרים) יגרמו לתוצאות שגויות בכל השלבים הבאים.

### הקוד:

```python
# טעינת הנתונים
df_customers = pd.read_csv("Customer Data.csv")

# סקירה ראשונית
print(df_customers.head())        # 5 שורות ראשונות
print(df_customers.info())        # סוגי עמודות + ערכים חסרים
print(df_customers.describe())    # סטטיסטיקות: min, max, mean, std...
```

### תוצאות:

- **8,950 לקוחות** (שורות)
- **18 תכונות** (עמודות)

### בדיקת ערכים חסרים:

```python
missing = df_customers.isnull().sum()
missing_cols = missing[missing > 0]
```

| עמודה | ערכים חסרים |
|-------|-------------|
| `MINIMUM_PAYMENTS` | 313 |
| `CREDIT_LIMIT` | 1 |

### טיפול בערכים חסרים - מילוי ב-Median

```python
for col in missing_cols.index:
    median_val = df_customers[col].median()
    df_customers[col] = df_customers[col].fillna(median_val)
```

### למה Median ולא Mean?

| שיטה | יתרון | חיסרון |
|------|-------|--------|
| **מחיקת שורות** | פשוט | מאבדים מידע (313 לקוחות!) |
| **Mean (ממוצע)** | קל לחישוב | **רגיש ל-outliers** - לקוח אחד עם BALANCE של 19,000 ימשוך את הממוצע למעלה |
| **Median (חציון)** | **עמיד ל-outliers** | קצת פחות "מדויק" סטטיסטית |

> **בנתוני כרטיסי אשראי יש הרבה outliers** (לקוחות עם הוצאות חריגות), ולכן **Median הוא הבחירה הנכונה**.

---

## חלק ב' - ניתוח חקר נתונים (EDA)

### למה EDA?

EDA (**Exploratory Data Analysis**) עוזר לנו להבין את הנתונים **לפני** שמריצים מודלים. בלי EDA, אנחנו "עיוורים" - לא יודעים אם יש בעיות בנתונים, אם יש דפוסים מעניינים, או אם יש קשרים בין המשתנים.

### 1. מטריצת קורלציה

```python
key_features = ["BALANCE", "PURCHASES", "CASH_ADVANCE", "CREDIT_LIMIT", "PAYMENTS"]
corr_customers = df_customers[key_features].corr()
```

**מה זה קורלציה?** מדד לקשר ליניארי בין שני משתנים:

| ערך | משמעות |
|-----|--------|
| קרוב ל-**1** | קשר חיובי חזק (כשאחד עולה, גם השני) |
| קרוב ל-**(-1)** | קשר שלילי חזק (כשאחד עולה, השני יורד) |
| קרוב ל-**0** | אין קשר ליניארי |

**ממצאים עיקריים:**

- **PURCHASES <-> PAYMENTS** : קורלציה חיובית - לקוחות שקונים יותר גם משלמים יותר (הגיוני)
- **BALANCE <-> CASH_ADVANCE** : קורלציה חיובית - משיכות מזומן מעלות את היתרה
- **PURCHASES <-> CASH_ADVANCE** : קורלציה נמוכה - לקוחות **נוטים לאחד מהשניים**, לא לשניהם

> **תובנה חשובה:** יש שני "סגנונות" שימוש בכרטיס - רכישות רגילות **או** משיכות מזומן. זה כבר רמז לסגמנטציה!

### 2. היסטוגרמות - BALANCE ו-PURCHASES

```python
axes_eda[0, 0].hist(df_customers["BALANCE"], bins=50)
axes_eda[0, 1].hist(df_customers["PURCHASES"], bins=50)
```

**מה לומדים מהיסטוגרמה?**

- שתי ההתפלגויות **מוטות ימינה (right-skewed)** - רוב הלקוחות עם ערכים נמוכים, ומעט לקוחות עם ערכים גבוהים מאוד
- זה אופייני לנתונים פיננסיים
- ה-outliers הם לגיטימיים (לקוחות VIP) ולא שגיאות

### 3. Scatter Plot - PURCHASES vs CASH_ADVANCE

```python
axes_eda[0, 2].scatter(df_customers["PURCHASES"], df_customers["CASH_ADVANCE"])
```

**מה לומדים?**

הנקודות מתפזרות **לאורך הצירים** (לא באלכסון). זה אומר:
- לקוחות עם רכישות גבוהות -> משיכות מזומן נמוכות
- לקוחות עם משיכות מזומן גבוהות -> רכישות נמוכות
- **אלו שתי קבוצות שונות מהותית**

### 4. Boxplots - זיהוי Outliers

```python
axes_eda[1, 1].boxplot(df_customers["CASH_ADVANCE"].dropna())
axes_eda[1, 2].boxplot(df_customers["CREDIT_LIMIT"].dropna())
```

**איך קוראים Boxplot:**

```
          |--- שפם עליון (Q3 + 1.5*IQR)
     ┌────┤
     │    │  <- רבעון 3 (Q3) - 75% מהנתונים מתחת
     │────│  <- חציון (Median) - הקו האדום
     │    │  <- רבעון 1 (Q1) - 25% מהנתונים מתחת
     └────┤
          |--- שפם תחתון (Q1 - 1.5*IQR)

     o  o  o  <- Outliers (מעבר לשפמים)
```

**חישוב Outliers בקוד:**

```python
Q1 = df_customers[col_name].quantile(0.25)
Q3 = df_customers[col_name].quantile(0.75)
IQR = Q3 - Q1                     # Inter-Quartile Range
lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR
n_outliers = ((df[col] < lower) | (df[col] > upper)).sum()
```

> **החלטה:** לא מסירים את ה-outliers! ב-Clustering הם עשויים לייצג **סגמנט לגיטימי** של לקוחות (למשל, לקוחות VIP).

---

## חלק ג' - קדם-עיבוד והתאמה למודל

### 1. בחירת תכונות

```python
cols_to_drop = ["CUST_ID", "TENURE"]
df_clustering = df_customers.drop(columns=cols_to_drop)
```

**למה הסרנו:**

| עמודה | סיבה להסרה |
|-------|------------|
| `CUST_ID` | מזהה ייחודי - אין בו מידע מספרי רלוונטי |
| `TENURE` | כמעט אחיד (רוב הלקוחות 12 חודשים) - לא תורם לפילוח |

**16 תכונות שנשארו** - כולן מספריות ורלוונטיות לדפוסי שימוש בכרטיס.

### 2. StandardScaler - נרמול התכונות

```python
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df_clustering)
```

**הנוסחה:**

```
X_scaled = (X - mean) / std
```

כל תכונה מקבלת: **ממוצע = 0**, **סטיית תקן = 1**

### למה Scaling הוא קריטי ב-K-Means?

K-Means מחשב **מרחקים** בין נקודות. בלי scaling:

| תכונה | טווח מקורי |
|-------|------------|
| `BALANCE` | 0 - 19,043 |
| `PURCHASES_FREQUENCY` | 0 - 1 |

> **הבעיה:** BALANCE עם טווח של אלפים **ישלוט לחלוטין** על חישוב המרחק, ו-PURCHASES_FREQUENCY (0-1) יהיה חסר משמעות.
>
> **אחרי Scaling:** שתי התכונות באותה סקאלה ותורמות באופן שווה.

---

## חלק ד' - מציאת מספר הקלאסטרים (Elbow Method)

### מה זה Elbow Method?

שיטה לבחור את **k** (מספר הקלאסטרים) האופטימלי.

**הרעיון:** מריצים K-Means עם k שונים ומודדים את ה-**Inertia** (WCSS):

```
Inertia = סכום ריבועי המרחקים של כל נקודה מהמרכז של הקלאסטר שלה
```

- ככל ש-k גדל -> Inertia יורד (יותר קלאסטרים = קלאסטרים קטנים יותר)
- מחפשים את ה-**"מרפק"** - הנקודה שבה קצב הירידה מואט משמעותית

### הקוד:

```python
inertias = []
K_range = range(2, 11)

for k in K_range:
    kmeans_temp = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans_temp.fit(X_scaled)
    inertias.append(kmeans_temp.inertia_)
```

### התוצאות:

| k | Inertia |
|---|---------|
| 2 | 118,899 |
| 3 | 103,156 |
| **4** | **90,185** |
| 5 | 82,710 |
| 6 | 76,009 |
| 7 | 70,911 |

### הבחירה: k = 4

**הסבר:** בגרף ה-Elbow רואים שהירידה ב-Inertia **מואטת משמעותית** אחרי k=4:

- מ-2 ל-3: ירידה של ~15,700
- מ-3 ל-4: ירידה של ~13,000
- מ-4 ל-5: ירידה של ~7,500 (הירידה התמתנה)
- מ-5 ל-6: ירידה של ~6,700

> k=4 הוא **האיזון הטוב ביותר** בין פשטות המודל לאיכות הפילוח. מעבר לזה, כל קלאסטר נוסף "שווה" פחות.

---

## חלק ה' - אימון KMeans ופרופילינג של קלאסטרים

### אימון המודל:

```python
kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
clusters = kmeans.fit_predict(X_scaled)
df_customers["Cluster"] = clusters
```

**פרמטרים:**
- `n_clusters=4` - מספר הקלאסטרים שבחרנו
- `random_state=42` - מבטיח תוצאות זהות בכל הרצה (שחזוריות)
- `n_init=10` - מריץ 10 אתחולים שונים ובוחר את הטוב ביותר

### חישוב ממוצעים (Centroids):

```python
cluster_profiles = df_customers.groupby("Cluster")[profile_cols].mean()
```

### תוצאות - 4 סגמנטים של לקוחות:

---

### Cluster 0 - "Frequent Buyers" (3,346 לקוחות, 37.4%)

| מדד | ערך |
|-----|-----|
| BALANCE | 898 |
| PURCHASES | 1,246 |
| CASH_ADVANCE | 210 |
| CREDIT_LIMIT | 4,218 |
| PAYMENTS | 1,337 |
| תדירות רכישות | 0.89 |
| תשלום מלא | 0.27 |

**פרופיל:** לקוחות פעילים שמשתמשים בכרטיס באופן קבוע לרכישות. תדירות גבוהה (0.89), היקף בינוני. לקוחות נאמנים ויציבים.

---

### Cluster 1 - "Low-Activity Customers" (3,988 לקוחות, 44.6%)

| מדד | ערך |
|-----|-----|
| BALANCE | 1,002 |
| PURCHASES | 272 |
| CASH_ADVANCE | 588 |
| CREDIT_LIMIT | 3,278 |
| PAYMENTS | 972 |
| תדירות רכישות | 0.17 |
| תשלום מלא | 0.08 |

**פרופיל:** הקבוצה הגדולה ביותר. לקוחות עם פעילות נמוכה - רכישות מעטות ובתדירות נמוכה. פוטנציאל לשימוש מוגבר עם תמריצים נכונים.

---

### Cluster 2 - "Cash-Advance Seekers" (1,215 לקוחות, 13.6%)

| מדד | ערך |
|-----|-----|
| BALANCE | 4,585 |
| PURCHASES | 502 |
| CASH_ADVANCE | **4,488** |
| CREDIT_LIMIT | 7,522 |
| PAYMENTS | 3,462 |
| תדירות רכישות | 0.29 |
| תשלום מלא | 0.03 |

**פרופיל:** לקוחות שמשתמשים בעיקר **במשיכות מזומן** מהכרטיס. יתרה גבוהה (4,585), רכישות נמוכות. אחוז תשלום מלא כמעט אפסי (0.03) - **סיכון אשראי גבוה**.

---

### Cluster 3 - "High-Value Customers" (401 לקוחות, 4.5%)

| מדד | ערך |
|-----|-----|
| BALANCE | 3,568 |
| PURCHASES | **7,763** |
| CASH_ADVANCE | 652 |
| CREDIT_LIMIT | **9,726** |
| PAYMENTS | **7,369** |
| תדירות רכישות | 0.95 |
| תשלום מלא | 0.29 |

**פרופיל:** לקוחות **פרימיום** - רכישות בהיקפים גבוהים מאוד (7,763), מסגרת אשראי הגבוהה ביותר (9,726), תדירות רכישות מקסימלית (0.95). לקוחות רווחיים עם פוטנציאל ל-upselling.

---

## ויזואליזציות

הקוד מייצר 3 קבצי גרפים:

1. **`clustering_eda_dashboard.png`** - 6 גרפי EDA (היסטוגרמות, scatter, boxplots, heatmap)
2. **`clustering_elbow.png`** - גרף Elbow לבחירת k
3. **`clustering_dashboard.png`** - 6 גרפי Clustering (גודל קלאסטרים, השוואות, scatter צבעוני)

---

## חלק ו' - סיכום ומסקנות עסקיות

### 1. תובנות עסקיות

| סגמנט | % | תובנה |
|-------|---|-------|
| Frequent Buyers | 37.4% | לקוחות נאמנים - חשוב לשמר אותם |
| Low-Activity | 44.6% | הפוטנציאל הגדול ביותר לצמיחה |
| Cash-Advance Seekers | 13.6% | סיכון אשראי - דורשים מעקב |
| High-Value | 4.5% | 4.5% מהלקוחות = פרימיום, רווחיים ביותר |

**התובנה המרכזית:** לקוחות כרטיסי אשראי **אינם קבוצה הומוגנית**. יש הבדלים מהותיים בדפוסי השימוש.

### 2. המלצות לצוות השיווק

#### Frequent Buyers - שימור ונאמנות

- **שיווק:** תוכנית נאמנות עם נקודות/cashback על רכישות
- **סיכון:** נמוך - לקוחות יציבים שמשלמים בזמן
- **מבצע:** הנחות בחנויות פופולריות, שדרוג כרטיס עם הטבות

#### Low-Activity Customers - הפעלה ומניעת נטישה

- **שיווק:** קמפיין הפעלה - "חזור להשתמש בכרטיס וקבל X"
- **סיכון:** סיכון לנטישה (churn) - צריך לפעול לפני שעוזבים
- **מבצע:** 0% עמלה על 3 חודשים ראשונים, cashback מוגבר

#### Cash-Advance Seekers - ניהול סיכון

- **שיווק:** הצעת הלוואות אישיות בריבית נמוכה יותר כחלופה למשיכות מזומן
- **סיכון:** מעקב צמוד - משיכות מזומן תכופות מצביעות על בעיות תזרים
- **מבצע:** בונוס על מעבר לרכישות רגילות במקום משיכות מזומן

#### High-Value Customers - VIP וupselling

- **שיווק:** שירות VIP, כרטיס פרימיום עם הטבות בלעדיות
- **סיכון:** נמוך - אבל חשוב לשמור על שביעות רצון כדי שלא יעזבו
- **מבצע:** הזמנות לאירועים, גישה ללאונג'ים בשדות תעופה, ביטוח נסיעות

---

## סיכום טכני - ספריות שנעשה בהן שימוש

```python
import pandas as pd                          # עיבוד נתונים
import numpy as np                           # חישובים מספריים
import matplotlib.pyplot as plt              # גרפים
import seaborn as sns                        # גרפים מתקדמים
from sklearn.cluster import KMeans           # אלגוריתם K-Means
from sklearn.preprocessing import StandardScaler  # נרמול תכונות
```

### תהליך העבודה המלא:

```
טעינת נתונים -> ניקוי (missing values) -> EDA -> בחירת features
-> Scaling -> Elbow -> KMeans -> פרופילינג -> מסקנות עסקיות
```
